템플릿 메서드 패턴(Template Method Pattern)은 이런 문제를 해결하는 디자인 패턴이다.

**템플릿 메서드 패턴과 비슷한 역할**을 하면서 **상속의 단점을 제거**할 수 있는 디자인 패턴이 바로 |전략 패턴|(StrategyPattern)이다.

탬플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 사용해서 문제를 해결했다.
전략 패턴은 변하지 않는 부분을 Context 라는 곳에 두고, 변하는 부분을 Strategy 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결한다.
    => 상속이 아니라 위임으로 문제를 해결하는 것이다.
    => 전략 패턴에서 Context 는 변하지 않는 템플릿 역할을 하고, Strategy 는 변하는 알고리즘 역할

        GOF 디자인 패턴에서 정의한 전략 패턴의 의도는 다음과 같다.
    알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자.
    전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.


바로 |스프링|에서 |의존관계 주입|에서 사용하는 방식이 바로 |전략 패턴|이다.

정리
    -변하는 부분 => Strategy을 구현해서 만든다.
    -변하지 않는 부분 => Context에 둔다
지금까지 일반적으로 이야기하는 전략 패턴에 대해서 알아보았다.
그리고 Context 의 내부 필드에 Strategy 를 주입해서 사용했다.

선 조립, 후 실행
Context 와 Strategy 를 한번 조립하고 나면 이후로는 Context 를 실행하기만 하면 된다.
    -> 단점도 있다 -> Context 와 Strategy를 조립한 이후에는 전략을 변경하기가 번거롭다.
        => Context에 setter를 제공해서 Strategy를 넘겨받아 변경하면 되지만, Context를 싱글톤으로 사용할 때는 동시성 이슈 등 고려할 점이 많다.
           그래서 전략을 실시간으로 변경해야 하면 차라리 이전에 개발한 테스트 코드처럼 Context를 하나 더 생성하고 그곳에 다른 Strategy를 주입하는 것이 더 나은 선택일 수 있다.

    -> Q.이렇게 먼저 조립하고 사용하는 방식보다 더 유연하게 전략 패턴을 사용하는 방법은 없을까?